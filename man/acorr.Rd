% Generated by roxygen2 (4.0.1): do not edit by hand
\name{acorr}
\alias{acorr}
\title{Calculates the full spatial autocorrelation on a raster using fft.}
\usage{
acorr(x, padlongitude = T, ...)
}
\arguments{
\item{x}{A raster* object. Missing values are indicated by NA.}

\item{padlongitude}{`logical` indicating whether to pad the file in the longitude (x) dimension.  If the raster spans from -180 to 180, set padlongitude=F}

\item{...}{passed to writeRaster.  If filename exists, output file will be written using writeRaster.  If NULL a temporary file is written as in the raster package.}
}
\value{
The spatial autocorrelation matrix
}
\description{
Applies the Wiener-Khinchin theorem to extract spatial autocorrelation using Fast Fourier Transform techniques.  This results in an extremely fast way to calculate a complete correlogram (correlation as a function of distance) for a raster image.
}
\examples{
\dontrun{
# packages used for the data generation
require(raster)
require(fields)
require(latticeExtra)
library(dplyr)

## first show the examples in Marcotte, Denis. 1996. “Fast Variogram Computation with FFT.” Computers & Geosciences 22 (10): 1175–86. doi:10.1016/S0098-3004(96)00026-X.
m1=raster(matrix(c(3,6,5,7,2,2,4,NA,0),ncol=3,byrow=T))
m2=raster(matrix(c(10,NA,5,NA,8,7,5,9,11),ncol=3,byrow=T))

ac=acorr2(m1,normalize=F)

## confirm nobs == nh11 on top of page 1179
10^as.matrix(ac[["nobs"]])

## comfirm acor= gh11 on top of page 1179
round(as.matrix(ac[["acor"]])/10,3)


#######################################################
## create a random raster with some spatial structure
nx=500  # size of raster
ny=round(nx*1.2)

r=raster(nrows=ny, ncols=nx,vals=1,xmn=-nx/2, xmx=nx/2, ymn=-ny/2, ymx=ny/2)
names(r)="z"

#Simulate a Gaussian random field with an exponential covariance function
## Theta is the scale of an exponential decay function.  This controls degree of autocorrelation, values close to 1 are close to random while values near nx/4 have high autocorrelation
theta=50

grid=list(x=seq(xmin(r),xmax(r)-1,by=res(r)[1]),y=seq(ymin(r),ymax(r)-1,res(r)[2]))

obj<-Exp.image.cov(grid=grid, theta=theta, setup=TRUE)
look<- sim.rf( obj)

values(r)=t(look)

################################
### now let's make the correlogram using fft()

## fit the complete spatial autocorrelation using fft()
## this function is the thing I need to confirm is working correctly
a1=acorr2(r)

## get directions for each shift to facilitate plotting of the correlogram
d2=acorr_dir(r)


## plot the autocorrlation and distance
  plot(r,ylab="Y",xlab="X",main="Original (Simulated) Raster")
  plot(a1,ylab="Shift in Y",xlab="Shift in X",main="Autocorrelation")
  plot(d2,ylab="Shift in Y",xlab="Shift in X",main="Direction from center (degrees)")

## now we can combine the acorr values with distance
ftd=data.frame(cor=values(a1))#,dir=values(d2))

## round to  faciliate binning
ftd$dist2=round(ftd$cor.dist,3)#,c(0:50,seq(51,1000,by=10)))
## take mean by km
ftd2 <- group_by(ftd, dist2)
ftd2 <- summarise(ftd2,
                  min = min(cor.acor, na.rm = TRUE),
                  max = max(cor.acor, na.rm = TRUE),
                  sd = sd(cor.acor, na.rm = TRUE),
                  mean = mean(cor.acor, na.rm = TRUE)
)

## this table has the correlation values and distance for each pixel
head(ftd2)

## plot the correlogram
xyplot(mean/10~dist2,type=c("l"),span=.3,data=ftd2,ylab="Correlation",xlab="Distance",main="Correlogram",sub="Different pixels within a distance class correspond to shifts of different directions (north, south, etc.) from the origin.  There is one point on the plot for each pixel.",auto.key=T,lwd=2,pch=16,cex=.25)+
  layer(panel.abline(h=0))

bwplot(cor.acor/10~cut(cor.dist,pretty(ftd$cor.dist,20)),data=ftd,ylab="Correlation",xlab="Distance",main="Correlogram",sub="Different pixels within a distance class correspond\\nto shifts of different directions (north, south, etc.) from the origin",col="black",fill="grey",scales=list(x=list(rot=45)))+
  layer(panel.abline(h=0))


###
## Matlab/Octave script
#x1=[3 6 5 ; 7 2 2 ; 4 NaN 0]
#[n,p]=size(x1); 
#ncols=2*p-1;
#nrows=2*n-1;
#nr2=5
#nc2=5
#x1id=~isnan(x1);
#x1(~x1id)=zeros(sum(sum(~x1id),1);
#fx1=fft2(x1,nr2,nc2);
#fx1id=fft2(x1id,nr2,nc2);
#nh11=round(real(ifft2(conj(fx1id) .*fx1id)));
#m1=real(ifft2(conj(fx1) .*fx1id)) ./max(nh11,1);
#m2=real(ifft2(conj(fx1id) .*fx1)) ./max(nh11,1)
#gh11=real(ifft2(conj(fx1) .*fx1)); gh11=gh11./max(nh11,1)-m1.*m2;

}
}
\references{
\url{en.wikipedia.org/wiki/WienerKhinchin_theorem}

Xianlin Ma, Tingting Yao, A program for 2D modeling (cross) correlogram tables using fast Fourier transform, Computers & Geosciences, Volume 27, Issue 7, August 2001, Pages 763-774, ISSN 0098-3004, \url{http://dx.doi.org/10.1016/S0098-3004(01)00007-3}.

\url{http://www.johnloomis.org/ece563/notes/freq/autoself/autoself.htm}

\url{http://www.seas.upenn.edu/~ese502/NOTEBOOK/Part_II/4_Variograms.pdf}
}

